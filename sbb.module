<?php

namespace Drupal\user;

use Drupal\user\UserAccessControlHandler;


/**
 * Implements hook_module_implements_alter().
 */
function sbb_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'entity_type_alter') {
    // Move our hook implementation to the bottom.
    $group = $implementations['sbb'];
    unset($implementations['sbb']);
    $implementations['sbb'] = $group;
  }
}

/**
 * Implements hook_entity_type_alter(&$entities);
 */
function sbb_entity_type_alter(array &$entity_types) {
  $entity_types['user']->setHandlerClass('access', 'BlockedUser');
}

class BlockedUser extends UserAccessControlHandler {
   
    /**
   * {@inheritdoc}
   */
  protected function checkAccess(EntityInterface $entity, $operation, AccountInterface $account) {
    /** @var \Drupal\user\UserInterface $entity*/

    // We don't treat the user label as privileged information, so this check
    // has to be the first one in order to allow labels for all users to be
    // viewed, including the special anonymous user.
    if ($operation === 'view label') {
      return AccessResult::allowed();
    }

    // The anonymous user's profile can neither be viewed, updated nor deleted.
    if ($entity->isAnonymous()) {
      return AccessResult::forbidden();
    }

    // Administrators can view/update/delete all user profiles.
    if ($account->hasPermission('administer users')) {
      return AccessResult::allowed()->cachePerPermissions();
    }

    switch ($operation) {
      case 'view':
        // Only allow view access if the account is active.
        if ($account->hasPermission('access user profiles') /*&& $entity->isActive()*/) {
          return AccessResult::allowed()->cachePerPermissions()->addCacheableDependency($entity);
        }
        // Users can view own profiles at all times.
        elseif ($account->id() == $entity->id()) {
          return AccessResult::allowed()->cachePerUser();
        }
        break;

      case 'update':
        // Users can always edit their own account.
        return AccessResult::allowedIf($account->id() == $entity->id())->cachePerUser();

      case 'delete':
        // Users with 'cancel account' permission can cancel their own account.
        return AccessResult::allowedIf($account->id() == $entity->id() && $account->hasPermission('cancel account'))->cachePerPermissions()->cachePerUser();
    }

    // No opinion.
    return AccessResult::neutral();
  }   
}


/**
 * Access callback to user entities.
 */
function sbb_metadata_user_access($op, $entity = NULL, $account = NULL, $entity_type) {
  $access = entity_metadata_user_access($op, $entity, $account, $entity_type);
  if (!$access && $op == 'view' && user_access('access user profiles', $account)) {
    $access = true;
  }
  return $access;
}


/**
 * Implements hook_query_alter().
 * Alter entity queries to always allow access to bloqued users.
 */
function sbb_query_alter(&$query) {
  if ($query->alterTags && !empty($query->alterTags['entityreference']) && isset($query->alterTags['user_access'])) {
    unset($query->propertyCondition);
    $query->entityCondition('status', 0, '>=');
  }
}


